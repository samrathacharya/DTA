/*
 * Copyright Â© 2019 Vigience Co., Ltd. All Rights Reserved
 */
 
// This class allows advanced customizations for the mapping of records from ovcSapEquipmentRep_V_EQUI__c to Asset.
// This class is constructed and executed each batch. Your class fields and properties will loose their values after each batch is complete.
// To retain data for the lifetime of the whole batch process, set the property persistentState.
//
// Scenario: ovcSapEquipmentRep
// Source Object: ovcSapEquipmentRep_V_EQUI__c
// Target Object: Asset
// Mapping Record Name: ovcSapEquipmentRep_Asset
// Direction: Inbound
// 
// Generated by Overcast 2019-11-26 08:41:13Z
// Your changes will not be overwritten when resaving the mapping.
//
global class Mapping_ovcSapEquipmentRep_Asset extends overcast.ObjectMapping.PluginExtension implements overcast.ObjectMapping.EventPlugin, overcast.ObjectMapping.BatchableEventPlugin {
    static final String chainedScenario = 'ovcSapAssetAddressRep';
    static final String chainedScenarioEquiStock = 'EquipmentSerialNoStockRep';
    static final String targetInputSetName = 'defaultFilter';
    Set<String> addressNumbers = new Set<String>();
    Set<String> equiStatusCodes = new Set<String>();
    Integer upsertSuccessCount = 0;

    // Base class properties (Do not uncomment these properties.)
    //
    // Set perisistentState with your own object/data to retain any state for the duration of the batch job.
    // global Object persistentState

    private Map<String, Asset> assetMap = new Map<String, Asset>();
    private Map<String, Id> objectPartnerMap = new Map<String, Id>();
    private Map<String, String> productMap = new Map<String, String>();
    //private Map<String, sapADRCRT.ADRC> adrcMap;

    global void execute(overcast__Run__c scenarioExecution, ovcSapEquipmentRep_V_EQUI__c[] records) {
        m_logger = new overcast.Logger(scenarioExecution.Id);
        overcast.ObjectMapping.MappingConfig config = new overcast.ObjectMapping.MappingConfig('ovcSapEquipmentRep_V_EQUI__c', records);
        config.rollbackOnError = false;
        // config.dmlOptions = new Database.DmlOptions(); // If set, config.dmlOptions will be used for the DML operations.
        // config.batchSize = 200; // Also set in UI. Allows dynamic setting of batch size.
        config.eventplugin = this;
        config.mappings = [SELECT overcast__Target__c, overcast__Map__c, overcast__Joins__c 
                    FROM overcast__IntegrationFieldMap__c 
                    WHERE overcast__ApexClass__c = 'Mapping_ovcSapEquipmentRep_Asset'];
        config.logger = m_logger;
        config.scenarioExecution = scenarioExecution;

        

        /* Custom logic */
        Map<String,ovcSapEquipmentRep_V_EQUI__c> equiMap = new Map<String,ovcSapEquipmentRep_V_EQUI__c>(); 
        Set<String> partnObjKeys = new Set<String>();
        Set<String> equiNumbers = new Set<String>();
        for (ovcSapEquipmentRep_V_EQUI__c equi : records) {
            equiNumbers.add(equi.EQUNR__c);
            equiMap.put(equi.OBJNR__c, equi);
            if(equi.ovcRep_Text_Exclude__c != true){
            	partnObjKeys.add(equi.OBJNR__c);    
            }
        }
                       
        if (!equiMap.isEmpty()) {
            //Check Equipment with DLFL Status 
            Set<String> equiKeyset = equiMap.keyset();  
            /*Set<String> delEquipment = getEquipmentStatus(equiKeyset,m_logger);
            for(String equiKey : equiKeyset){
                if(delEquipment.contains(equiKey)){
                    equiMap.get(equiKey).ovcEquipment_Deletion_Status__c = true;
                }                
            } */ 
            Map<String,Object> equipmentStatMap = getEquipmentStatus(equiKeyset);    
            Map<String,Object> equipmentStatDescription = getEquipmentStatusDesc(equipmentStatMap,m_logger);     
            for(String equiKey : equipmentStatDescription.keySet()){
                Map<String,Object> equiStatDescMap = (Map<String,Object>) equipmentStatMap.get(equiKey);
                String individualStat = (String) equiStatDescMap.get('INDSTAT');
                String objectStat = (String) equiStatDescMap.get('OBJSTAT');
                if(individualStat.contains('DLFL')){
                    equiMap.get(equiKey).ovcEquipment_Deletion_Status__c = true;
                }  
                equiMap.get(equiKey).ovcEquipment_Status__c = individualStat;
                equiMap.get(equiKey).ovcEquipment_Stat_Desc__c = objectStat;
            }                   
            
            if(!partnObjKeys.isEmpty()){
                //// Get IHPA records for Ship-to Partners
                overcast.Logger dummyLogger = new overcast.Logger('PlantMaintenancePartnerRT');
                PlantMaintenancePartnerRT pmpRequest = new PlantMaintenancePartnerRT();
                overcast.Query q = new overcast.Query();
                q.where_x = new overcast.Predicate(null, overcast.Predicate.FilterType.AND1, '');
                q.where_x.add(new overcast.Predicate('PARVW', overcast.Predicate.FilterType.EQUALS, 'WE'));
                q.where_x.add(new overcast.Predicate('OBJNR', overcast.Predicate.FilterType.IN1, partnObjKeys));
                PlantMaintenancePartnerRT pmpResponse;
                try {
                    if (Test.isRunningTest()) {
                        Map<String, Object> tr = new Map<String, Object>{ 'IHPA' => new List<Object>{ new Map<String, Object>{ 'PARNR' => '0001234567', 'OBJNR' => '000000000012345678' } } };
                        pmpRequest.testResponse = JSON.serialize(new Map<String, Object>{ 'output' => tr });
                    }
                    pmpResponse = pmpRequest.runQuery(q, dummyLogger, null);
                } catch(Exception ex) {
                    logError(ex.getMessage());
                    if (ex.getCause() != null) {
                        logError(ex.getCause().getMessage());
                    }
                    setStatusToError();
                }
                if (pmpResponse != null && !pmpResponse.IHPA.isEmpty()) {
                    for (PlantMaintenancePartnerRT.IHPA pmp : pmpResponse.IHPA) {
                        if (equiMap.containsKey(pmp.OBJNR)) {
                            equiMap.get(pmp.OBJNR).KUNDE__c = pmp.PARNR;
                        }
                    }
                }                
            }
        }


        overcast.ObjectMapping.run(config);

        // Perform your post-mapping processing here.
        logInfo(String.format('Successfully upserted {0} records', new List<String>{ String.valueOf(upsertSuccessCount) }));
        if (!addressNumbers.isEmpty()) {
            // Replicate the address details via chained scenario
            logInfo(String.format('Enqueueing scenario [{0}] for {1} address numbers', new List<String>{ chainedScenario, String.valueOf(addressNumbers.size()) }));
            overcast.Predicate p = new overcast.Predicate('ADDRNUMBER__c', overcast.Predicate.FilterType.IN1, new List<String>(addressNumbers));
            overcast.Scenario.runWithDynamicInput(chainedScenario, targetInputSetName, p, overcast.Predicate.FilterType.AND1, m_logger);
        }

        /*if(!equiNumbers.isEmpty()){
            overcast.Predicate predStock = new overcast.Predicate('EQUNR__c', overcast.Predicate.FilterType.IN1, new List<String>(equiNumbers));
            overcast.Scenario.runWithDynamicInput(chainedScenarioEquiStock, targetInputSetName, predStock, overcast.Predicate.FilterType.AND1, m_logger);
        }*/

        this.saveLogs();
    }

    // Begin ObjectMapping.EventPlugin interface implementation

    // BeforeUpsert Is called for each record that will be inserted/updated into the target object.
    // If the target record has an ID it will be updated, otherwise inserted.
    // Return true to accept the record for insert/update. False to reject the record.
    global boolean beforeUpsert(sobject sourceRecord, sobject targetRecord) {
        ovcSapEquipmentRep_V_EQUI__c source = (ovcSapEquipmentRep_V_EQUI__c)sourceRecord;
        Asset target = (Asset)targetRecord;        
        
        /* custom logic */
        /*if (target.Id == null && target.AccountId == null) {
            logWarning(String.format('Skipping [{0}]: partner account [{1}] could not be found', new String[]{source.OBJNR__c, source.KUNDE__c}));
            setStatusToWarning();
            return false;
        }*/
        
        //custom logic change
        if (target.Id == null) {
            if(source.ovcRep_Text_Exclude__c == true || source.ovcEquipment_Deletion_Status__c == true){               
				return false;                
            }
            else if(target.AccountId == null){
                logWarning(String.format('Skipping [{0}]: partner account [{1}] could not be found', new String[]{source.OBJNR__c, source.KUNDE__c}));
                setStatusToWarning();
				return false;                  
            }
        }
        
        // Set Account lookup
        // if (objectPartnerMap.keySet().contains(source.OBJNR__c)) {
        //     target.AccountId = objectPartnerMap.get(source.OBJNR__c);
        //     logDebug(String.format('Found AccountId [{0}] for [{1}]', new String[]{target.AccountId, source.OBJNR__c}));
        // } else {
        //     logError(String.format('Skipping [{0}]: neither partner nor default account could be found', new String[]{source.OBJNR__c}));
        //     setStatusToError();
        //     return false;
        // }

        //target.RecordTypeId = equiRecordTypeId;

        // // Set Parent Asset
        // if (!String.isEmpty(source.HEQUI__c) && assetMap.containsKey(source.HEQUI__c)) {
        //     target.ParentId = assetMap.get(source.HEQUI__c).Id;
        // } else if (assetMap.containsKey(source.TPLNR__c)) {
        //     target.ParentId = assetMap.get(source.TPLNR__c).Id;
        // }

        // Set Name
        if (String.isEmpty(target.Name)) {
            target.Name = source.EQUNR__c;
        }

        // // Set Product lookup
        // if (String.isNotBlank(source.MATNR__c) && productMap.containsKey(source.MATNR__c)) {
        //     target.Product2Id = productMap.get(source.MATNR__c);
        // }

        return true;
    }
    
    // AfterInsert Is called after both insert And update DML operations are successfull. 
    // If rollbackOnError Is true And a DML exception occurs when inserting Or updating, the transaction Is rolled back And AfterInsert Is Not called.
    // If rollbackOnError Is false And a DML exception occurs when inserting Or updating, AfterInsert Is called And saveResults will contain the error messages.
    global void afterInsert(sobject[] insertedRecords, Database.SaveResult[] saveResults) { 
        integer failedCount = 0;
        for (integer i = 0; i < saveResults.size(); ++i) {
            Database.Saveresult saveResult = saveResults[i];
            sobject insertedRecord = insertedRecords[i];
            
            if (!saveResult.isSuccess()) {
                list<string> fieldErrors = new list<string>(); 
                for (string fieldName : saveResult.getErrors()[0].getFields()) {
                    fieldErrors.add(fieldName + '=' + string.valueof(insertedRecord.get(fieldName)));
                }
                
                LogError(string.format('Failed to save record [ID={0}, Message={1}:{2}, {3}]', 
                    new string[]{
                        insertedRecord.Id, 
                        string.valueof(saveResult.getErrors()[0].getStatusCode()), 
                        saveResult.getErrors()[0].getMessage(), 
                        string.join(fieldErrors, ', ')
                    }));
                
                ++failedCount;
            } else {
                addressNumbers.add((String)insertedRecord.get('ovcSapAddressNumber__c'));
            }
        }
        if (failedCount > 0) {
            logError(string.format('{0} of {1} records failed to save.', 
                new string[]{ 
                    string.valueof(failedCount), 
                    string.valueof(insertedRecords.size()) 
                }));
            setStatusToError();
        }

        upsertSuccessCount += insertedRecords.size() - failedCount;

    }
    
    // AfterUpdate Is called after both insert And update DML operations are successfull. 
    // If rollbackOnError Is true And a DML exception occurs when inserting Or updating, the transaction Is rolled back And AfterUpdate Is Not called.
    // If rollbackOnError Is false And a DML exception occurs when inserting Or updating, AfterUpdate Is called And saveResults will contain the error messages.
    global void afterUpdate(sobject[] updatedRecords, Database.SaveResult[] saveResults) {  
        afterInsert(updatedRecords, saveResults);
    }

    // End of interface implementation
        
    // Begin helper methods
        
    // Log an error message to the scenario execution log
    global void logError(String message) {
        m_logger.addLog('ERROR', '[Mapping_ovcSapEquipmentRep_Asset] ' + message);
    }
    
    // Log an warning message to the scenario execution log
    global void logWarning(String message) {
        m_logger.addLog('WARN', '[Mapping_ovcSapEquipmentRep_Asset] ' + message);
    }
    
    // Log an info message to the scenario execution log
    global void logInfo(String message) {
        m_logger.addLog('INFO', '[Mapping_ovcSapEquipmentRep_Asset] ' + message);
    }

    // Log a debug message to the scenario execution log
    global void logDebug(String message) {
        m_logger.addLog('DEBUG', '[Mapping_ovcSapEquipmentRep_Asset] ' + message);
    }
    
    // Set the scenario execution status to error
    global void setStatusToError() {
        m_logger.setStatusCode(400);
    }
    
    // Set the scenario execution status to warning
    global void setStatusToWarning() {
        m_logger.setStatusCode(500);
    }
    
    global void saveLogs() {
        m_logger.commitToDatabase();
    }
    
    // End helper methods

    @testvisible
    private overcast.Logger m_logger;

    global override overcast.Logger getLogger() {
        return m_logger;
    }
    
    /*@TestVisible
    private OrderUserStatus testEquiStatus;
    @TestVisible
    private Set<String> getEquipmentStatus(
        set<String> objKeys,
        overcast.logger logger    
    ){
        
        OrderUserStatus request = new OrderUserStatus();
        overcast.Predicate pred = new overcast.Predicate();
        pred.type = overcast.Predicate.FilterType.AND1;
        pred.add(
             new overcast.Predicate(
                'OBJNR',
                overcast.Predicate.FilterType.IN1 ,
                objKeys         
            )
        );
        //Check stat I0076
        pred.add(
             new overcast.Predicate(
                'STAT_x',
                overcast.Predicate.FilterType.EQUALS ,
                'I0076'        
            )
        );
        pred.add(
             new overcast.Predicate(
                'INACT',
                overcast.Predicate.FilterType.EQUALS ,
                ''     
            )
        );   
        
        overcast.Query q = new overcast.Query();
        q.where_x = pred;
        Overcast.Logger loggerX = new Overcast.Logger('OrderUserStatus');
        OrderUserStatus resp = Test.isRunningTest()
        ? testEquiStatus
        : request.runQuery(q, loggerX, null);        
        
        List<Object> jestList = (List<Object>) resp.get('JEST');               
        Set<String> delFlagEqui = new Set<String>();   
        
        for(Object equiStatusObj : jestList){
            Map<String,Object> equiStatusMap = (Map<String,Object>) equiStatusObj;
            String delFlagObj = (String) equiStatusMap.get('OBJNR');
            delFlagEqui.add(delFlagObj);      
        }
        return delFlagEqui;
    } */      

    @TestVisible
    private OrderUserStatus testEquiStatus;
    @TestVisible
    private Map<String,Object> getEquipmentStatus(
        set<String> objKeys 
    ){
        
        OrderUserStatus request = new OrderUserStatus();
        overcast.Predicate pred = new overcast.Predicate();
        pred.type = overcast.Predicate.FilterType.AND1;
        pred.add(
             new overcast.Predicate(
                'OBJNR',
                overcast.Predicate.FilterType.IN1 ,
                objKeys         
            )
        );
        //Check stat I0076
        /*pred.add(
             new overcast.Predicate(
                'STAT_x',
                overcast.Predicate.FilterType.EQUALS ,
                'I0076'        
            )
        );*/
        pred.add(
             new overcast.Predicate(
                'INACT',
                overcast.Predicate.FilterType.EQUALS ,
                ''     
            )
        );   
        
        overcast.Query q = new overcast.Query();
        q.where_x = pred;
        //Overcast.Logger loggerX = new Overcast.Logger('OrderUserStatus');
        OrderUserStatus resp = Test.isRunningTest()
        ? testEquiStatus
        : request.runQuery(q, null, null);        
        
        List<Object> jestList = (List<Object>) resp.get('JEST');               
        /*Set<String> delFlagEqui = new Set<String>();   
        for(Object equiStatusObj : jestList){
            Map<String,Object> equiStatusMap = (Map<String,Object>) equiStatusObj;
            String delFlagObj = (String) equiStatusMap.get('OBJNR');
            delFlagEqui.add(delFlagObj);      
        }
        return delFlagEqui;*/
        Map<String,Object> equiStatMap = new Map<String,Object>();   
        List<String> statList = new List<String>();
        for(Object equiStatusObj : jestList){
            Map<String,Object> equiStatusMap = (Map<String,Object>) equiStatusObj;
            String objNr = (String) equiStatusMap.get('OBJNR');
            String equiStat = (String) equiStatusMap.get('STAT_x');
            this.equiStatusCodes.add(equiStat);
            if(equiStatMap.get(objNr) != null){
                statList = (List<String>) equiStatMap.get(objNr);  
            }
            statList.add(equiStat);
            equiStatMap.put(objNr,statList);  
        }
        return equiStatMap;
    }  

    @TestVisible
    private SystemStatusDesc testEquiStatusDesc;
    @TestVisible
    private Map<String,Object> getEquipmentStatusDesc(
        Map<String,Object> equiStatDesc,
        overcast.logger logger  
    ){
        SystemStatusDesc request = new SystemStatusDesc();
        overcast.Predicate pred = new overcast.Predicate();
        pred.type = overcast.Predicate.FilterType.AND1;
        pred.add(
             new overcast.Predicate(
                'ISTAT',
                overcast.Predicate.FilterType.IN1 ,
                this.equiStatusCodes         
            )
        );
        pred.add(
             new overcast.Predicate(
                'SPRAS',
                overcast.Predicate.FilterType.EQUALS ,
                'E'     
            )
        );  
        
        overcast.Query q = new overcast.Query();
        q.where_x = pred;
        Overcast.Logger loggerX = new Overcast.Logger('SystemStatusDesc');
        SystemStatusDesc resp = Test.isRunningTest()
        ? testEquiStatusDesc
        : request.runQuery(q, loggerX, null);        
        
        List<String> indStatus = new List<String>();
        List<String> objStatus = new List<String>(); 
        Map<String,Object> descriptionMap = new Map<String,Object>();   
        for (String objnr : equiStatDesc.keySet()) {
            List<String> statCodeList = (List<String>)equiStatDesc.get(objnr);
            for(SystemStatusDesc.TJ02T rec : resp.TJ02T){
                if(statCodeList.contains(rec.ISTAT)){
                    indStatus.add(rec.TXT04);
                    objStatus.add(rec.TXT30);
                }
            } 
            descriptionMap.put('INDSTAT', String.join(new List<String>(indStatus), ' - '));
            descriptionMap.put('OBJSTAT', String.join(new List<String>(objStatus), ' - '));   
            equiStatDesc.put(objnr,descriptionMap);              
        }
        return equiStatDesc;
    }           

}