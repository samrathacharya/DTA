/*
 * Copyright Â© 2019 Vigience Co., Ltd. All Rights Reserved
 */

// This class allows advanced customizations for the mapping of records from ovcSapFuncLocationRep_IFLO__c to Asset.
//
// Scenario: ovcSapFuncLocationRep
// Source Object: ovcSapFuncLocationRep_IFLO__c
// Target Object: Asset
// Mapping Record Name: ovcSapFncLocationRep_Asset
// Direction: Inbound
// 
// Generated by Overcast 2019-11-26 02:41:22Z
// Your changes will not be overwritten when resaving the mapping.
//
global class Mapping_ovcSapFncLocationRep_Asset implements overcast.ObjectMapping.EventPlugin, overcast.ObjectMapping.BatchableEventPlugin {

    static final String addressScenario = 'ovcSapAssetAddressRep';

    private Map<String, Id> objectPartnerMap = new Map<String, Id>();
    private Map<String, Asset> assetMap = new Map<String, Asset>();

    global void execute(overcast__Run__c scenarioExecution, ovcSapFuncLocationRep_IFLO__c[] records) {
        overcast.EpgwController.MappingConfig config = new overcast.EpgwController.MappingConfig('ovcSapFuncLocationRep_IFLO__c', records);
        config.rollbackOnError = false;
        // config.dmlOptions = new Database.DmlOptions(); // If set, config.dmlOptions will be used for the DML operations.
        // config.batchSize = 200; // Also set in UI. Allows dynamic setting of batch size.
        config.eventplugin = this;
        config.mappings = [SELECT overcast__Target__c, overcast__Map__c, overcast__Joins__c 
                    FROM overcast__IntegrationFieldMap__c 
                    WHERE overcast__ApexClass__c = 'Mapping_ovcSapFncLocationRep_Asset'];

        m_logger = new overcast.Logger(scenarioExecution.Id);

        /* Custom Logic */
        Set<String> objectKeys = new Set<String>();
        Set<String> sapNumbers = new Set<String>();
        Set<String> addressNumbers = new Set<String>();
        for (ovcSapFuncLocationRep_IFLO__c iflo : records) {
            objectKeys.add(iflo.OBJNR__c);
            sapNumbers.add(iflo.TPLNR__c);
            sapNumbers.add(iflo.TPLMA__c);
            if (String.isNotBlank(iflo.ADRNR__c)) {
                addressNumbers.add(iflo.ADRNR__c);
            }
        }

        logDebug('Object keys: ' + objectKeys.size());

        //Get a map of the partner from SapPMPartner__c object
        objectPartnerMap = OvcAssetHelper.getPartnerMap(objectKeys, 'WE');
        logDebug('SapPMPartner map size: ' + objectPartnerMap.size());

        //Get a map of asset
        assetMap = OvcAssetHelper.getAssetMap(sapNumbers);


        //Create inputset to retrieve SAP address info 
        if (!addressNumbers.isEmpty()) {
            String keyDate = Datetime.now().format('YYYYMMdd');

            overcast.Predicate p = new overcast.Predicate(null, overcast.Predicate.FilterType.AND1, '');
            p.add(new overcast.Predicate('ADDRNUMBER__c', overcast.Predicate.FilterType.IN1, new List<String>(addressNumbers)));
            p.add(new overcast.Predicate('NATION__c', overcast.Predicate.FilterType.EQUALS, ''));
            p.add(new overcast.Predicate('DATE_FROM__c', overcast.Predicate.FilterType.LESS_THAN_OR_EQUAL_TO, keyDate));
            p.add(new overcast.Predicate('DATE_TO__c', overcast.Predicate.FilterType.GREATER_THAN_OR_EQUAL_TO, keyDate));

            overcast__ScenarioTables__c[] st = [SELECT Id, overcast__Scenario__c FROM overcast__ScenarioTables__c WHERE overcast__Scenario__r.Name = :addressScenario LIMIT 1];
            if (st.isEmpty()) {
                logError('Unable to find scenario information for ' + addressScenario);
                setStatusToError();
            } else {
                overcast__InputSet__c input = new overcast__InputSet__c(Name = 'auto_' + overcast.Utilities.NewGuid(), overcast__Scenario__c = st[0].overcast__Scenario__c, overcast__ScenarioTables__c = st[0].Id);
                input.overcast__Condition2__c = p.serialize();
                insert input;

                logInfo(String.format('Enqueueing scenario [{0}] for {1} customers with InputSet [{2}]', new String[]{addressScenario, String.valueOf(addressNumbers.size()), input.Name}));
                System.enqueueJob(new OvcAssetHelper.ExecuteScenarioQueue(addressScenario, input.Name));

            }
        }

        overcast.EpgwController.RunMappingTrigger(config);

        this.saveLogs();
    }

    // Begin ObjectMapping.EventPlugin interface implementation

    // BeforeUpsert Is called for each record that will be inserted/updated into the target object.
    // If the target record has an ID it will be updated, otherwise inserted.
    // Return true to accept the record for insert/update. False to reject the record.
    global boolean beforeUpsert(sobject sourceRecord, sobject targetRecord) {
        ovcSapFuncLocationRep_IFLO__c source = (ovcSapFuncLocationRep_IFLO__c)sourceRecord;
        Asset target = (Asset)targetRecord;

        //set Account
        if (objectPartnerMap.containsKey(source.OBJNR__c)) {
            target.AccountId = objectPartnerMap.get(source.OBJNR__c);
            logDebug(String.format('Found AccountId [{0}] for [{1}]', new String[]{target.AccountId, source.OBJNR__c}));

        } else {
            logError(String.format('Skipping [{0}]: neither partner nor default account could be found', new String[]{source.OBJNR__c}));
            setStatusToError();
            return false;
        }

        //set Parent asset
        if (String.isBlank(source.TPLMA__c)) {
            target.ParentId = null;
        } else if (assetMap.containsKey(source.TPLMA__c)) {
            target.ParentId = assetMap.get(source.TPLMA__c).Id;
        }

        //set Name
        if (String.isEmpty(target.Name)) {
            target.Name = source.TPLNR__c;
        }

        return true;
    }
    
    // AfterInsert Is called after both insert And update DML operations are successfull. 
    // If rollbackOnError Is true And a DML exception occurs when inserting Or updating, the transaction Is rolled back And AfterInsert Is Not called.
    // If rollbackOnError Is false And a DML exception occurs when inserting Or updating, AfterInsert Is called And saveResults will contain the error messages.
    global void afterInsert(sobject[] insertedRecords, Database.SaveResult[] saveResults) { 
        integer failedCount = 0;
        for (integer i = 0; i < saveResults.size(); ++i) {
            Database.Saveresult saveResult = saveResults[i];
            
            if (!saveResult.isSuccess()) {
                sobject insertedRecord = insertedRecords[i];
                list<string> fieldErrors = new list<string>(); 
                for (string fieldName : saveResult.getErrors()[0].getFields()) {
                    fieldErrors.add(fieldName + '=' + string.valueof(insertedRecord.get(fieldName)));
                }
                
                LogError(string.format('Failed to save record [ID={0}, Message={1}:{2}, {3}]', 
                    new string[]{
                        insertedRecord.Id, 
                        string.valueof(saveResult.getErrors()[0].getStatusCode()), 
                        saveResult.getErrors()[0].getMessage(), 
                        string.join(fieldErrors, ', ')
                    }));
                
                ++failedCount;
            }
        }
        if (failedCount > 0) {
            logError(string.format('{0} of {1} records failed to save.', 
                new string[]{ 
                    string.valueof(failedCount), 
                    string.valueof(insertedRecords.size()) 
                }));
            setStatusToError();
        }
    }
    
    // AfterUpdate Is called after both insert And update DML operations are successfull. 
    // If rollbackOnError Is true And a DML exception occurs when inserting Or updating, the transaction Is rolled back And AfterUpdate Is Not called.
    // If rollbackOnError Is false And a DML exception occurs when inserting Or updating, AfterUpdate Is called And saveResults will contain the error messages.
    global void afterUpdate(sobject[] updatedRecords, Database.SaveResult[] saveResults) {  
        afterInsert(updatedRecords, saveResults);
    }

    // End of interface implementation
        
    // Begin helper methods
        
    // Log an error message to the scenario execution log
    global void logError(String message) {
        m_logger.addLog('ERROR', '[Mapping_ovcSapFncLocationRep_Asset] ' + message);
    }
    
    // Log an warning message to the scenario execution log
    global void logWarning(String message) {
        m_logger.addLog('WARN', '[Mapping_ovcSapFncLocationRep_Asset] ' + message);
    }
    
    // Log an info message to the scenario execution log
    global void logInfo(String message) {
        m_logger.addLog('INFO', '[Mapping_ovcSapFncLocationRep_Asset] ' + message);
    }

    // Log a debug message to the scenario execution log
    global void logDebug(String message) {
        m_logger.addLog('DEBUG', '[Mapping_ovcSapFncLocationRep_Asset] ' + message);
    }
    
    // Set the scenario execution status to error
    global void setStatusToError() {
        m_logger.setStatusCode(400);
    }
    
    // Set the scenario execution status to warning
    global void setStatusToWarning() {
        m_logger.setStatusCode(500);
    }
    
    global void saveLogs() {
        m_logger.commitToDatabase();
    }
    
    // End helper methods

    @testvisible
    private overcast.Logger m_logger;
}